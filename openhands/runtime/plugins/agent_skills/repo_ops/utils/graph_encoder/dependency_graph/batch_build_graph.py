import argparse
import json
import os
import os.path as osp
import pickle
import time
from pathlib import Path

import torch.multiprocessing as mp
from build_graph import add_edges, build_graph, convert_edges_to_invokes
from build_graph_v2 import build_graph_v2
from datasets import load_dataset
from openhands.runtime.plugins.agent_skills.repo_ops.utils.util import setup_swebench_repo


def list_folders(path):
    return [p.name for p in Path(path).iterdir() if p.is_dir()]


def run(
    rank,
    repo_queue,
    repo_path,
    out_path,
    version,
    download_repo=False,
    instance_data=None,
):
    while True:
        try:
            repo_name = repo_queue.get_nowait()
        except Exception:
            # Queue is empty
            break

        output_file = f'{osp.join(out_path, repo_name)}.pkl'
        if osp.exists(output_file):
            print(f'[{rank}] {repo_name} already processed, skipping.')
            continue

        if download_repo:
            # get process specific base dir
            repo_base_dir = str(osp.join(repo_path, str(rank)))
            os.makedirs(repo_base_dir, exist_ok=True)
            # clone and check actual repo
            repo_dir = setup_swebench_repo(
                instance_data=instance_data[repo_name], repo_base_dir=repo_base_dir
            )
        else:
            repo_dir = osp.join(repo_path, repo_name)

        try:
            if version == 'v1':
                G = build_graph(repo_dir)
                add_edges(G)
                G = convert_edges_to_invokes(G)
            elif version == 'v2':
                G = build_graph_v2(repo_dir)
            elif version == 'v2.1':
                G = build_graph_v2(repo_dir, global_import=True)
            else:
                raise NotImplementedError(f"Version '{version}' is not implemented.")

            with open(output_file, 'wb') as f:
                pickle.dump(G, f)
            print(f'[{rank}] Processed {repo_name}')
        except Exception as e:
            print(f'[{rank}] Error processing {repo_name}: {e}')


if __name__ == '__main__':
    DEFAULT_REPO_PATH = 'DATA/repo/'
    DEFAULT_TRAINING_REPO_PATH = 'DATA/repo_train/'

    parser = argparse.ArgumentParser()
    parser.add_argument('--version', type=str, default='v2.1')
    parser.add_argument('--repo_path', type=str, default=DEFAULT_REPO_PATH)
    parser.add_argument('--instance_id_path', type=str, default='')
    parser.add_argument('--out_path', type=str, default='')
    parser.add_argument('--num_processes', type=int, default=30)
    # parser.add_argument('--download_repo', action='store_true')
    args = parser.parse_args()

    assert args.version in ['v1', 'v2', 'v2.1']

    if args.out_path == '':
        if args.version == 'v1':
            args.out_path = 'DATA/dependency-graph/'
        else:
            args.out_path = f'DATA/dependency_graph_{args.version}/'
    os.makedirs(args.out_path, exist_ok=True)

    # load repo instance id and instance_data
    if args.instance_id_path != '':
        is_download_repo = True
        if args.repo_path == DEFAULT_REPO_PATH:
            args.repo_path = DEFAULT_TRAINING_REPO_PATH

        with open(args.instance_id_path, 'r') as f:
            repo_folders = json.loads(f.read())

        swe_bench_data = load_dataset('princeton-nlp/SWE-bench', split='train')
        selected_instance_data = {}
        for instance in swe_bench_data:
            if instance['instance_id'] in repo_folders:
                selected_instance_data[instance['instance_id']] = instance
    else:
        repo_folders = list_folders(args.repo_path)
        selected_instance_data = None
        is_download_repo = False
    os.makedirs(args.repo_path, exist_ok=True)

    # Create a shared queue and add repositories to it
    manager = mp.Manager()
    queue = manager.Queue()
    for repo in repo_folders:
        queue.put(repo)

    start_time = time.time()

    # Start multiprocessing with a global queue
    mp.spawn(
        run,
        nprocs=args.num_processes,
        args=(
            queue,
            args.repo_path,
            args.out_path,
            args.version,
            is_download_repo,
            selected_instance_data,
        ),
        join=True,
    )

    end_time = time.time()
    print(f'Total Execution time = {end_time - start_time:.3f}s')
